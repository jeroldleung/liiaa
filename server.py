import base64
import json
import os
from io import BytesIO
import soundfile as sf
import opuslib

import numpy as np
from dotenv import load_dotenv
from openai import OpenAI
from pydub import AudioSegment
from websockets.sync.server import ServerConnection, serve


def wav_to_opus(audio_str: str) -> bytes:
    """Convert a base64-encoded wav audio string to an opus-encoded audio string."""
    wav_bytes = base64.b64decode(audio_str)  # decoded audio string to audio bytes
    audio_np = np.frombuffer(wav_bytes, dtype=np.int16)
    wav_buf = BytesIO()
    sf.write(wav_buf, audio_np, samplerate=16000, format="wav")
    audio = AudioSegment.from_file(wav_buf, format="wav")  # load wav data
    audio.set_channels(1).set_frame_rate(16000)
    encoder = opuslib.Encoder(16000, 1, opuslib.APPLICATION_AUDIO)

    frame_duration = 60  # 60ms per frame
    frame_size = int(16000 * frame_duration / 1000)  # 960 samples/frame
    raw_data = audio.raw_data

    for i in range(0, len(raw_data), frame_size * 2):
        chunk = raw_data[i:i + frame_size * 2]
        if len(chunk) < frame_size * 2:
            chunk += b'\x00' * (frame_size * 2 - len(chunk))
        np_frame = np.frombuffer(chunk, dtype=np.int16)
        opus_data = encoder.encode(np_frame.tobytes(), frame_size)
        yield opus_data


def chat(websocket: ServerConnection):
    client = OpenAI(base_url=os.getenv("BASE_URL"), api_key=os.getenv("API_KEY"))
    memory = [{"role": "system", "content": "You are a helpful assistant."}]

    def handshake():
        to_device = {
            "type": "hello",
            "transport": "websocket",
            "audio_params": {"sample_rate": 16000},
        }
        websocket.send(json.dumps(to_device))

    def stream_llm_output():
        memory.append({"role": "user", "content": "你好"})
        for chunk in client.chat.completions.create(
            model=os.getenv("MODEL"),
            messages=memory,
            modalities=["text", "audio"],
            audio={"voice": "Cherry", "format": "wav"},
            stream=True,
        ):
            if not hasattr(chunk.choices[0].delta, "audio"):
                continue
            if "data" in chunk.choices[0].delta.audio:
                audio_str = chunk.choices[0].delta.audio["data"]
                for piece in wav_to_opus(audio_str):
                    websocket.send(piece)

    def send_audio_test():
        audio_bytes = [
            b"X`\xb9Rb\x1dS\xa47\xe3\x08l*g \x9c\x17-\xb2{\x92\xde\x1c\x8a\x0fS\xd9X\x9bj\x00\x9f1\xb0\xbe\x81\xd3#\xe2@\xf0=\xd8\xda\x84\x9a\xeb/`S\x9e\xcb3\x14\xc4Y\xe4EA\xa88\x93\xdf\xc7\xc9;\x99\xaa\xc1\xfbB\x01~\r\xaav\xb7\r\x906=\xab\xb0\x07\xe4 \xb9\x87\xa6S\xc3\xe7=\xee}\xf8\x9dg==\xd0g\xf9\x98@\xa2",
            b"X\xe9?\xe1\xf0\xdaj\xb80\xb1\xbd\x8c\t\xef\xe3\xd4\xb5\xc2\xef\x11/\xde[\xe9\x99LC\x04K\x0e\xaf\xed\x06\xa3\xfc\x8e\x13\x84\xf1\xa8\x89\xaf]\x89F\x81\xc6\xd8\x80\\.J\xf1\xe3\x05Z_\x83i*O5\xe9%\x81\xfb\xad\xa6v|\xc7\xb7\xd9\x11\xc6\x12\xea\xb1\x8aG\xef\xe9\\\x88\x1d@\x96\xb6/\xdd]\x1dw\xf48\xdeR\xc5\xd9\xe3aA\xf2\x86.+\xba\xd0",
            b"X\xe8\x01?0\xcc\xbbv\xf8?\xf1\xe9\xec2r\xabw\xb7\x9f:K}[\nZqE~o\xf8\x1b\x92w\xae! \x14.\xb9Z\x7f#d.e1I0\xd5\xf6\xbaez\xd8_\xc3\x17\xd1\xc9\x84\xdc\xff\x8e\xcd@\xe9t}\x04\xbf\x80\xb1h\xf9\x9fEg\xb2\xef\xbf\xb7\x86\xadR\xf5\xb5I\x9f\xf5*\x99&\x1103OV\xf3\xdf\x1b\xee\xa3\xd9\x8c\xc3\xfape0L(eh\x9e\xe3\xd8\xd0\x8bV\xc4\xe1\xd0B5\x9d[\xb2J\x0ev\xebq\\Fy\xb93\x0e\x80",
            b'X\xe8\\\xc4\xd1S\xbf}iK\r\xc5~\xd1\xc8\x1a\xe6\xa9Q\x03\x86\xc8D}\t-a\x10z\xdeD"\x7f\xb0\xf7;C)\x16X_\xa4\x0f\xa7\xba\xd9\xad}0C\x05B_.\xdc\x07}\x8cH\x16\x07\x85\xce\x0e\x18\x9a"CBc\x9c\xfao\xc9\xa1\xd8\xf1H\xfd\xf8%*ii\xaf\xfc\xa0`\xc3\xb6\x06\x05]\xb6\xca\x84%\x9a\xe3\xf9d\xfa92\\\xd1\xf0\xbb\xc2\xeb\xb6\xb6\x9cc\xc9\t\xaa\x1f\x11\xbc\xb9\x9b\x9f1\xca\x90',
            b"X\xe7\xe3z\xa5.X\xf3LG\xd8\xdc`\xe1\xf6!3\xf0C\x92\t\xf5O\xcfQ\xb0\x99\xbf2\xe2\xe3L\xa6~\xf5\xc1\x84%\x04\x92\xea\x1aQ\xb5\x8dD\xd0$\xfeD%L\x8f)O\xc4\x05!h\x0b|<`Z\x1dz\xb3\x88\x99\xf4\xeb%V\r\xd5\xd66\xf4e\x8e\xa2\x17uE\x19\xbbK\x86\xe5T\x9c\xe77\xe6\xe7\r\x08\xaa\x03;e}*",
            b"X\xea\xfe\x1d\xd3\xa3\xe4|jb\xd1\xdf\xcf\x1e8\xf6\xf7\xd8\xad\x9b\xf2[I\xa7d\xef\xc5\xce\x91^4\x9e\xdd3\xb6\xc4\x06L\x0c\x81L\xc1\xd7)\xba\x91\x13\x83\xa0\xa9>Q,P4\x14;\xcb\xbaak\xf5\x10X\x01\xdb\x829\xb6|\x19\x14\xb2\x1cf\xf7\xcf\x906\xaf\xc6!2d\xcb\x0fx\x8f\x02#<\xc3PNj\x81\xcc<\x11\xc3w(p\x8a;]\xdf\xaaJ\xa3cHg\xf0",
            b"X\xedH\xe8pJz\xc7\xe9\xe4\xe42\xaa\xd3\xb0AW)\xb1K\xda\x19\x8b\xad\xe192\xce\x12+\xd4\x8b\x1728k\x10\xa5\xb7\xbaO\xaa\x92\xf68Y@\x1f\xb0}m\xe1\x0c\xc0\xa6\x95R\xe6f\xe4}\xed/\xa3.\xf1\x11\x88\x9aw4t\x86\x0c",
            b"X\xedY\x15\xc0Yt\x08b\x12\xc1\x1e\xbf\x16\xf6]p\xd6\x1f\x00\xc1G\x99x\xbd\x9a\x8b\xdb\x8f\xdcx\x14\xbd\x8e\x88G\xf7\x98_>(j\xa9\xd4s\xd9\x1a\x12#\xb6\xd0\xd7c\xac\xdf\xfd\x0fr\x974\xf8\x85i\xf6\x0f\x03\x86\xa5\xacQ{\xed\xaf\xa3@h\x04\xdet\xc4\xde\x06>\xb4g\xf7r\xc8N!AEwop*\x80\x8f\xeb\x1a\xbb\xde\xcat\x11\x9d0\x01ao.Z\xf7\x97\xad\xe0P\x03\xa5\xb7\x9e\x80\xa9\xa2\x89-\x80",
            b"X\xec\x80\x99\xcd\x13\x9bl\xbcv<\x15r)\xcc\xc8^]UD\xce\x91\xf0=?\xaa6@\xc0\x1e\x87\xed\x82\x19\xe2\xc0\xd4+\xe8\x80\xcf\xab^`Wg\x92\xe0\x971\x14\xa6\xda\xa8\xd0!\xa4\xc5P\xf3\xeax\xa2\xceL\xb6K\xb7\x89\xa9Q\xff\xf3\x8b\xb1\xe4\x02\xec\xadH$\xef\x19\xf4\xf5p@\xef\xd1k\x04\xa3\xcd\xbc\x04[\x0e\xcf\xec@\xcc\rb\xee\xd4/\xad\xcaM\x1e\x9c\x84\xfa\x01\x133<#\x15\xd4f\x9f\xb5I\xce)f\x93<\x0e)\x05\xb8u\xa0",
            b"X\xeeU\x14\x07\xda\x0c\x00|\x8c\xdb\xb2\xfdd\xe5\xce\xb5\xa1\xd6\xdaXD\xbf5\x08;\xfaOd\x8b\xf8x\xd7\xc6\xad\xed\x1c?\x9e\xd3\xcd\x1b\x14.0\x00n\xc7&\xd7j\xca8\xa7S\xc5'\xa5m1\xf0V\x9f\xffL\xf0\x13Q~;\xb0?\xd6<\xa2\xd4\xc1\xaa\xf4.\x92\x0e",
            b"X\xed\x88\x14\xe1\x97\xe0*IR1'\xec\xb6]l\nY\\\xf6\xf0\x97\x9b2\n\xecT\xa1\xd5\xfc\xf8\xc1\xb5\x1e\xb5\x0e\xedH;\x87t\xb9k\xa3\xf5\x1f>\x8d\xbcz\xa4\xfd\x1f\x1a\xec\xb7\x82i\xa7\xb0\xf3\xbf\x12\xf1\xbd\x04+\x8c{L\xa9\x1dQ\xcf>\x97\xd5ag\xfe",
            b"X\xed2^0q\xb8_\xfd\xde\xaaC\x13\xc37\xe2\x00\x05\xef\xb7Go!y\xc8\x18\xa1C\xfa\x83\x1e6C\xf3/w*\x13W\xac\x98\xda:m\x10N\x82\x03\xd2\xdc\x86s1\xd3R\x8b8\x18\xa2\x8e\x0f\xab\x81\xe9\xb3\xcf\x8c\xf3\x9c\xdb\xf9\xdc\xbb\x04V\xe0m\xbe\xba\xa0\x12\xdd\xb8e\xc8\xfe\x18\x1df]\x82\xf5Q\xd7\xab\xddA\xa2\xcdI\xaa\xc4\x0c\xfb\x15\xff\xc8D\x87\xb3\x95\xe6\xcbr\x15\xa2\xd6J\x9c\xde\xc5,F\x13}w_P",
            b'X!r\xb3W\x88F\x88B\x1cX|\xda\x92\xa6\xd3\xff]\x92\x9f\xa1\xcd\xc6\xfeq|?&\n\x1d\xbfF\xf6\x83d\xec5XP\xc7b\x8e\x11=\x06\xd8l\xa8Q\nk\xf5\x8fh\x1c4E\xafa)\x93\xab\x8f\x8a\xf3\x05\x80x<\t`\xa9M\x89l\xe4"\x92\x19p\x10h\xd3\x83x\xa9S\xa5\x90\x15\xa4\xc5qj',
            b'X\x83\x14\xf5\x9c\x1f\xb3\x0fO\x89\xa3\xeb\x0cV\xe0\x12\x04\xb2?T\xbc6\xedW\xa2\x96\x98\x17z\xa6a\x18`\xe8\xd1\xa6\xe8\xc6\xba\r\xae\x81\x94z4I\xdb\xbe\xc3\xcf7\x9f\x989\xb5\x92\x01[\x12\x90\xa5_\n1Y\x164\xeba@\xa3I/\xb93\xe3\x05\x14\x10\xd4xa\xce\r\xc1\xbd\xceg|\xf0\x1bE"\xc1\xd8\xbc\xcc\x02\xf0|\x18\x0fO\xe77\xd8\x8c\x9d.$\xc0',
        ]
        for audio in audio_bytes:
            websocket.send(audio)

    while True:
        msg = websocket.recv()
        print(msg)
        if isinstance(msg, str):
            msg = json.loads(msg)
            if msg["type"] == "hello":
                handshake()
            elif msg["type"] == "listen":
                if msg["state"] == "stop":
                    message = {"type": "tts", "state": "start", "text": ""}
                    websocket.send(json.dumps(message))
                    stream_llm_output()
                    message = {"type": "tts", "state": "stop", "text": ""}
                    websocket.send(json.dumps(message))


def main():
    with serve(chat, "0.0.0.0", 8000) as server:
        server.serve_forever()


if __name__ == "__main__":
    assert load_dotenv(), "Failed to load environment variables"
    main()
